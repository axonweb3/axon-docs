"use strict";(self.webpackChunkaxon_docs=self.webpackChunkaxon_docs||[]).push([[6663],{3905:(t,e,a)=>{a.d(e,{Zo:()=>s,kt:()=>k});var n=a(7294);function l(t,e,a){return e in t?Object.defineProperty(t,e,{value:a,enumerable:!0,configurable:!0,writable:!0}):t[e]=a,t}function r(t,e){var a=Object.keys(t);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(t);e&&(n=n.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),a.push.apply(a,n)}return a}function i(t){for(var e=1;e<arguments.length;e++){var a=null!=arguments[e]?arguments[e]:{};e%2?r(Object(a),!0).forEach((function(e){l(t,e,a[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(a)):r(Object(a)).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(a,e))}))}return t}function p(t,e){if(null==t)return{};var a,n,l=function(t,e){if(null==t)return{};var a,n,l={},r=Object.keys(t);for(n=0;n<r.length;n++)a=r[n],e.indexOf(a)>=0||(l[a]=t[a]);return l}(t,e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(t);for(n=0;n<r.length;n++)a=r[n],e.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(t,a)&&(l[a]=t[a])}return l}var o=n.createContext({}),u=function(t){var e=n.useContext(o),a=e;return t&&(a="function"==typeof t?t(e):i(i({},e),t)),a},s=function(t){var e=u(t.components);return n.createElement(o.Provider,{value:e},t.children)},d="mdxType",c={inlineCode:"code",wrapper:function(t){var e=t.children;return n.createElement(n.Fragment,{},e)}},m=n.forwardRef((function(t,e){var a=t.components,l=t.mdxType,r=t.originalType,o=t.parentName,s=p(t,["components","mdxType","originalType","parentName"]),d=u(a),m=l,k=d["".concat(o,".").concat(m)]||d[m]||c[m]||r;return a?n.createElement(k,i(i({ref:e},s),{},{components:a})):n.createElement(k,i({ref:e},s))}));function k(t,e){var a=arguments,l=e&&e.mdxType;if("string"==typeof t||l){var r=a.length,i=new Array(r);i[0]=m;var p={};for(var o in e)hasOwnProperty.call(e,o)&&(p[o]=e[o]);p.originalType=t,p[d]="string"==typeof t?t:l,i[1]=p;for(var u=2;u<r;u++)i[u]=a[u];return n.createElement.apply(null,i)}return n.createElement.apply(null,a)}m.displayName="MDXCreateElement"},62:(t,e,a)=>{a.r(e),a.d(e,{assets:()=>o,contentTitle:()=>i,default:()=>c,frontMatter:()=>r,metadata:()=>p,toc:()=>u});var n=a(7462),l=(a(7294),a(3905));a(4996);const r={title:"Precompile Contracts",hide_title:!0,sidebar_position:2},i="Precompile Contracts",p={unversionedId:"contract/precompile_contracts",id:"contract/precompile_contracts",title:"Precompile Contracts",description:"On top of a set of opcodes, EVM also offers advanced functionalities through precompiled contracts. These are special contracts bundled with EVM at fixed addresses that can be called with a determined gas. The gas is purely the contractual cost, neither the cost of the call itself nor the instructions to put the parameters in memory.",source:"@site/docs/contract/precompile_contracts.md",sourceDirName:"contract",slug:"/contract/precompile_contracts",permalink:"/contract/precompile_contracts",draft:!1,editUrl:"https://github.com/axonweb3/axon-docs/edit/main/docs/contract/precompile_contracts.md",tags:[],version:"current",lastUpdatedAt:1703466658,formattedLastUpdatedAt:"Dec 25, 2023",sidebarPosition:2,frontMatter:{title:"Precompile Contracts",hide_title:!0,sidebar_position:2},sidebar:"tutorialSidebar",previous:{title:"System Contracts",permalink:"/contract/system_contacts"},next:{title:"Genesis Contracts",permalink:"/contract/genesis_contracts"}},o={},u=[{value:"EcRecover",id:"ecrecover",level:3},{value:"SHA2-256",id:"sha2-256",level:3},{value:"RIPEMD-160",id:"ripemd-160",level:3},{value:"Identity",id:"identity",level:3},{value:"Modexp",id:"modexp",level:3},{value:"EcAdd",id:"ecadd",level:3},{value:"EcMul",id:"ecmul",level:3},{value:"EcPairing",id:"ecpairing",level:3},{value:"Blake2f",id:"blake2f",level:3},{value:"GetHeader",id:"getheader",level:3},{value:"Inputs",id:"inputs",level:4},{value:"Output",id:"output",level:4},{value:"Example",id:"example",level:4},{value:"GetCell",id:"getcell",level:3},{value:"Inputs",id:"inputs-1",level:4},{value:"Output",id:"output-1",level:4},{value:"Example",id:"example-1",level:4},{value:"CallCkbVm",id:"callckbvm",level:3},{value:"Inputs",id:"inputs-2",level:4},{value:"Output",id:"output-2",level:4},{value:"Example",id:"example-2",level:4},{value:"CkbBlake2b",id:"ckbblake2b",level:3},{value:"Inputs",id:"inputs-3",level:4},{value:"Output",id:"output-3",level:4},{value:"CkbMbtVerify",id:"ckbmbtverify",level:3},{value:"Inputs",id:"inputs-4",level:4},{value:"Output",id:"output-4",level:4},{value:"Example",id:"example-3",level:4}],s={toc:u},d="wrapper";function c(t){let{components:e,...a}=t;return(0,l.kt)(d,(0,n.Z)({},s,a,{components:e,mdxType:"MDXLayout"}),(0,l.kt)("h1",{id:"precompile-contracts"},"Precompile Contracts"),(0,l.kt)("p",null,"On top of a set of opcodes, EVM also offers advanced functionalities through precompiled contracts. These are special contracts bundled with EVM at fixed addresses that can be called with a determined gas. The gas is purely the contractual cost, neither the cost of the call itself nor the instructions to put the parameters in memory."),(0,l.kt)("p",null,"Precompiled contract addresses start from 1 and increment for each contract. New hardforks may introduce new precompiled contracts. Similar to the regular contracts, new contracts are called from opcodes with instructions, such as\xa0",(0,l.kt)("a",{parentName:"p",href:"https://www.evm.codes/#F1"},"CALL"),"."),(0,l.kt)("p",null,"For all precompiled contracts, inputs that are shorter than expected are assumed to be virtually padded with zeros at the end, whereas any surplus bytes at the end of inputs that are longer than expected are ignored."),(0,l.kt)("p",null,"The address precompile contract is described by the last 2 bytes:"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Byte range ","[0..18]"),(0,l.kt)("th",{parentName:"tr",align:null},"Byte range ","[18..20]"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"000000000000000000000000000000000000"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"addr"))))),(0,l.kt)("h3",{id:"ecrecover"},"EcRecover"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"ADDRESS"),(0,l.kt)("th",{parentName:"tr",align:null},"MINIMUM GAS"),(0,l.kt)("th",{parentName:"tr",align:null},"INPUT"),(0,l.kt)("th",{parentName:"tr",align:null},"OUTPUT"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"0x0000000000000000000000000000000000000001"),(0,l.kt)("td",{parentName:"tr",align:null},"3000"),(0,l.kt)("td",{parentName:"tr",align:null},"hash, v, r, s"),(0,l.kt)("td",{parentName:"tr",align:null},"publicAddress")))),(0,l.kt)("p",null,"EcRecover is a elliptic curve digital signature algorithm (ECDSA) public key recovery function. For details, see ",(0,l.kt)("a",{parentName:"p",href:"https://www.evm.codes/precompiled#0x01?fork=london"},"this page"),"."),(0,l.kt)("h3",{id:"sha2-256"},"SHA2-256"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"ADDRESS"),(0,l.kt)("th",{parentName:"tr",align:null},"MINIMUM GAS"),(0,l.kt)("th",{parentName:"tr",align:null},"INPUT"),(0,l.kt)("th",{parentName:"tr",align:null},"OUTPUT"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"0x0000000000000000000000000000000000000002"),(0,l.kt)("td",{parentName:"tr",align:null},"60"),(0,l.kt)("td",{parentName:"tr",align:null},"data"),(0,l.kt)("td",{parentName:"tr",align:null},"hash")))),(0,l.kt)("p",null,"SHA2-256 is the hash function used in Bitcoin. For details, see ",(0,l.kt)("a",{parentName:"p",href:"https://www.evm.codes/precompiled#0x02?fork=london"},"this page")),(0,l.kt)("h3",{id:"ripemd-160"},"RIPEMD-160"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"ADDRESS"),(0,l.kt)("th",{parentName:"tr",align:null},"MINIMUM GAS"),(0,l.kt)("th",{parentName:"tr",align:null},"INPUT"),(0,l.kt)("th",{parentName:"tr",align:null},"OUTPUT"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"0x0000000000000000000000000000000000000003"),(0,l.kt)("td",{parentName:"tr",align:null},"600"),(0,l.kt)("td",{parentName:"tr",align:null},"data"),(0,l.kt)("td",{parentName:"tr",align:null},"hash")))),(0,l.kt)("p",null,"A hash function. For details, see ",(0,l.kt)("a",{parentName:"p",href:"https://www.evm.codes/precompiled#0x03?fork=london"},"this page"),"."),(0,l.kt)("h3",{id:"identity"},"Identity"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"ADDRESS"),(0,l.kt)("th",{parentName:"tr",align:null},"MINIMUM GAS"),(0,l.kt)("th",{parentName:"tr",align:null},"INPUT"),(0,l.kt)("th",{parentName:"tr",align:null},"OUTPUT"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"0x0000000000000000000000000000000000000004"),(0,l.kt)("td",{parentName:"tr",align:null},"15"),(0,l.kt)("td",{parentName:"tr",align:null},"data"),(0,l.kt)("td",{parentName:"tr",align:null},"data")))),(0,l.kt)("p",null,"Identity copies and returns input data. For details, see ",(0,l.kt)("a",{parentName:"p",href:"https://www.evm.codes/precompiled#0x04?fork=london"},"this page"),"."),(0,l.kt)("h3",{id:"modexp"},"Modexp"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"ADDRESS"),(0,l.kt)("th",{parentName:"tr",align:null},"MINIMUM GAS"),(0,l.kt)("th",{parentName:"tr",align:null},"INPUT"),(0,l.kt)("th",{parentName:"tr",align:null},"OUTPUT"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"0x0000000000000000000000000000000000000005"),(0,l.kt)("td",{parentName:"tr",align:null},"200"),(0,l.kt)("td",{parentName:"tr",align:null},"Bsize, Esize, Msize, B, E, M"),(0,l.kt)("td",{parentName:"tr",align:null},"value")))),(0,l.kt)("p",null,"Modexp is an arbitrary-precision exponentiation under modulo. For details, see ",(0,l.kt)("a",{parentName:"p",href:"https://www.evm.codes/precompiled#0x05?fork=london"},"this page"),"."),(0,l.kt)("h3",{id:"ecadd"},"EcAdd"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"ADDRESS"),(0,l.kt)("th",{parentName:"tr",align:null},"MINIMUM GAS"),(0,l.kt)("th",{parentName:"tr",align:null},"INPUT"),(0,l.kt)("th",{parentName:"tr",align:null},"OUTPUT"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"0x0000000000000000000000000000000000000006"),(0,l.kt)("td",{parentName:"tr",align:null},"150"),(0,l.kt)("td",{parentName:"tr",align:null},"x1, x2, y1, y2"),(0,l.kt)("td",{parentName:"tr",align:null},"x, y")))),(0,l.kt)("p",null,"EcAdd is the point addition (ADD) on the elliptic curve alt_bn128. For details, see ",(0,l.kt)("a",{parentName:"p",href:"https://www.evm.codes/precompiled#0x06?fork=london"},"this page"),"."),(0,l.kt)("h3",{id:"ecmul"},"EcMul"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"ADDRESS"),(0,l.kt)("th",{parentName:"tr",align:null},"MINIMUM GAS"),(0,l.kt)("th",{parentName:"tr",align:null},"INPUT"),(0,l.kt)("th",{parentName:"tr",align:null},"OUTPUT"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"0x0000000000000000000000000000000000000007"),(0,l.kt)("td",{parentName:"tr",align:null},"6000"),(0,l.kt)("td",{parentName:"tr",align:null},"x1, x2, s"),(0,l.kt)("td",{parentName:"tr",align:null},"x, y")))),(0,l.kt)("p",null,"EcMul is the scalar multiplication (MUL) on the elliptic curve alt_bn128. For details, see ",(0,l.kt)("a",{parentName:"p",href:"https://www.evm.codes/precompiled#0x07?fork=london"},"this page"),"."),(0,l.kt)("h3",{id:"ecpairing"},"EcPairing"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"ADDRESS"),(0,l.kt)("th",{parentName:"tr",align:null},"MINIMUM GAS"),(0,l.kt)("th",{parentName:"tr",align:null},"INPUT"),(0,l.kt)("th",{parentName:"tr",align:null},"OUTPUT"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"0x0000000000000000000000000000000000000008"),(0,l.kt)("td",{parentName:"tr",align:null},"45000"),(0,l.kt)("td",{parentName:"tr",align:null},"x1, y1, x2, y2, \u2026, xk, yk"),(0,l.kt)("td",{parentName:"tr",align:null},"success")))),(0,l.kt)("p",null,"EcPairing is the bilinear function on groups on the elliptic curve ",(0,l.kt)("inlineCode",{parentName:"p"},"alt_bn128"),". For details, see ",(0,l.kt)("a",{parentName:"p",href:"https://www.evm.codes/precompiled#0x08?fork=london"},"this page"),"."),(0,l.kt)("h3",{id:"blake2f"},"Blake2f"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"ADDRESS"),(0,l.kt)("th",{parentName:"tr",align:null},"MINIMUM GAS"),(0,l.kt)("th",{parentName:"tr",align:null},"INPUT"),(0,l.kt)("th",{parentName:"tr",align:null},"OUTPUT"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"0x0000000000000000000000000000000000000009"),(0,l.kt)("td",{parentName:"tr",align:null},"0"),(0,l.kt)("td",{parentName:"tr",align:null},"rounds, h, m, t, f"),(0,l.kt)("td",{parentName:"tr",align:null},"h")))),(0,l.kt)("p",null,"Blake2f is the compression function F used in the BLAKE2 cryptographic hashing algorithm. For details,  see ",(0,l.kt)("a",{parentName:"p",href:"https://www.evm.codes/precompiled#0x09?fork=london"},"this page"),"."),(0,l.kt)("h3",{id:"getheader"},"GetHeader"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"ADDRESS"),(0,l.kt)("th",{parentName:"tr",align:null},"MINIMUM GAS"),(0,l.kt)("th",{parentName:"tr",align:null},"INPUT"),(0,l.kt)("th",{parentName:"tr",align:null},"OUTPUT"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"0x0000000000000000000000000000000000000102"),(0,l.kt)("td",{parentName:"tr",align:null},"42000"),(0,l.kt)("td",{parentName:"tr",align:null},"hash"),(0,l.kt)("td",{parentName:"tr",align:null},"header view")))),(0,l.kt)("p",null,"Get the header of a relayed CKB block header by hash."),(0,l.kt)("h4",{id:"inputs"},"Inputs"),(0,l.kt)("details",null,(0,l.kt)("summary",null,"Click here to view ABI"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"struct Input {\n    bytes32 hash;\n}\n"))),(0,l.kt)("h4",{id:"output"},"Output"),(0,l.kt)("details",null,(0,l.kt)("summary",null,"Click here to view ABI"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"struct Header {\n    uint32 version;\n    uint32 compactTarget;\n    uint64 timestamp;\n    uint64 number;\n    uint64 epoch;\n    bytes32 parentHash;\n    bytes32 transactionsRoot;\n    bytes32 proposalsHash;\n    bytes32 extraHash;\n    bytes32 dao;\n    uint128 nonce;\n    bytes extension;\n    bytes32 blockHash;\n}\n"))),(0,l.kt)("h4",{id:"example"},"Example"),(0,l.kt)("details",null,(0,l.kt)("summary",null,"Click here to view example"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"contract GetCkbHeader {\n    event GetHeaderEvent(CKBHeader);\n    event NotGetHeaderEvent();\n\n    int8 ret;\n\n    function getHeader(bytes32 blockHash) public returns (CKBHeader memory) {\n        address get_header_addr = address(0x0102);\n        (bool isSuccess, bytes memory res) = get_header_addr.staticcall(\n            abi.encode(blockHash)\n        );\n\n        CKBHeader memory header;\n        if (isSuccess) {\n            header = abi.decode(res, (CKBHeader));\n            emit GetHeaderEvent(header);\n        } else {\n            emit NotGetHeaderEvent();\n        }\n        return header;\n    }\n}\n\n"))),(0,l.kt)("h3",{id:"getcell"},"GetCell"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"ADDRESS"),(0,l.kt)("th",{parentName:"tr",align:null},"MINIMUM GAS"),(0,l.kt)("th",{parentName:"tr",align:null},"INPUT"),(0,l.kt)("th",{parentName:"tr",align:null},"OUTPUT"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"0x0000000000000000000000000000000000000103"),(0,l.kt)("td",{parentName:"tr",align:null},"42000"),(0,l.kt)("td",{parentName:"tr",align:null},"out point"),(0,l.kt)("td",{parentName:"tr",align:null},"cell info")))),(0,l.kt)("p",null,"Get the relayed cell information by out point."),(0,l.kt)("h4",{id:"inputs-1"},"Inputs"),(0,l.kt)("details",null,(0,l.kt)("summary",null,"Click here to view ABI"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"struct OutPoint {\n    bytes32 txHash;\n    uint32 index;\n}\n"))),(0,l.kt)("h4",{id:"output-1"},"Output"),(0,l.kt)("details",null,(0,l.kt)("summary",null,"Click here to view ABI"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"struct CellInfo {\n    OutPoint outPoint;\n    CellOutput output;\n    bytes data;\n}\n\nstruct CellOutput {\n    uint64 capacity;\n    Script lock;\n    Script[] type_;\n}\n"))),(0,l.kt)("h4",{id:"example-1"},"Example"),(0,l.kt)("details",null,(0,l.kt)("summary",null,"Click here to view example"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"contract GetCkbCell {\n    event GetCellEvent(OutPoint);\n    event NotGetCellEvent();\n\n    int8 ret;\n\n    function getCell(bytes32 blockHash) public returns (CellInfo memory) {\n        address get_cell_addr = address(0x0103);\n        (bool isSuccess, bytes memory res) = get_cell_addr.staticcall(\n            abi.encode(outPoint)\n        );\n\n        CellInfo memory cell;\n        if (isSuccess) {\n            cell = abi.decode(res, (CellInfo));\n            emit GetCellEvent(cell);\n        } else {\n            emit NotGetCellEvent();\n        }\n        return cell;\n    }\n}\n\n"))),(0,l.kt)("h3",{id:"callckbvm"},"CallCkbVm"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"ADDRESS"),(0,l.kt)("th",{parentName:"tr",align:null},"MINIMUM GAS"),(0,l.kt)("th",{parentName:"tr",align:null},"INPUT"),(0,l.kt)("th",{parentName:"tr",align:null},"OUTPUT"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"0x0000000000000000000000000000000000000104"),(0,l.kt)("td",{parentName:"tr",align:null},"300"),(0,l.kt)("td",{parentName:"tr",align:null},"cell dep, args"),(0,l.kt)("td",{parentName:"tr",align:null},"big-endian bytes")))),(0,l.kt)("p",null,"Call a script that runs in CKB-VM and return the execute result."),(0,l.kt)("h4",{id:"inputs-2"},"Inputs"),(0,l.kt)("details",null,(0,l.kt)("summary",null,"Click here to view ABI"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"struct CellDep {\n    OutPoint outPoint;\n    uint32   index;\n}\n\nstruct InputArgs {\n    bytes[] args;\n}\n"))),(0,l.kt)("h4",{id:"output-2"},"Output"),(0,l.kt)("details",null,(0,l.kt)("summary",null,"Click here to view ABI"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"struct Result {\n    int8 ret;\n}\n"))),(0,l.kt)("h4",{id:"example-2"},"Example"),(0,l.kt)("details",null,(0,l.kt)("summary",null,"Click here to view example"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"contract CallCkbVm {\n    event CallCkbVmEvent(int8);\n    event NotGetCellEvent();\n\n    int8 ret;\n\n    function testCallCkbVm(\n        bytes32 txHash,\n        uint32 index,\n        uint8 depType,\n        bytes[] memory input_args\n    ) public {\n        OutPoint memory outPoint = OutPoint(txHash, index);\n        (bool isSuccess, bytes memory res) = address(0x0104).staticcall(\n            abi.encode(CellDep(outPoint, depType), input_args)\n        );\n\n        if (isSuccess) {\n            ret = int8(uint8(res[0]));\n            emit CallCkbVmEvent(ret);\n        } else {\n            emit NotGetCellEvent();\n        }\n    }\n\n    function callCkbVm() public view returns (int8) {\n        return ret;\n    }\n}\n\n"))),(0,l.kt)("h3",{id:"ckbblake2b"},"CkbBlake2b"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"ADDRESS"),(0,l.kt)("th",{parentName:"tr",align:null},"MINIMUM GAS"),(0,l.kt)("th",{parentName:"tr",align:null},"INPUT"),(0,l.kt)("th",{parentName:"tr",align:null},"OUTPUT"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"0x0000000000000000000000000000000000000106"),(0,l.kt)("td",{parentName:"tr",align:null},"60"),(0,l.kt)("td",{parentName:"tr",align:null},"data"),(0,l.kt)("td",{parentName:"tr",align:null},"hash")))),(0,l.kt)("p",null,"Calculate the ckb-blake2b hash."),(0,l.kt)("h4",{id:"inputs-3"},"Inputs"),(0,l.kt)("details",null,(0,l.kt)("summary",null,"Click here to view ABI"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"struct Input {\n    byte[] data;\n}\n"))),(0,l.kt)("h4",{id:"output-3"},"Output"),(0,l.kt)("details",null,(0,l.kt)("summary",null,"Click here to view ABI"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"struct Output {\n    bytes32 hash;\n}\n"))),(0,l.kt)("h3",{id:"ckbmbtverify"},"CkbMbtVerify"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"ADDRESS"),(0,l.kt)("th",{parentName:"tr",align:null},"MINIMUM GAS"),(0,l.kt)("th",{parentName:"tr",align:null},"INPUT"),(0,l.kt)("th",{parentName:"tr",align:null},"OUTPUT"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"0x0000000000000000000000000000000000000107"),(0,l.kt)("td",{parentName:"tr",align:null},"56000"),(0,l.kt)("td",{parentName:"tr",align:null},"verify proof payload"),(0,l.kt)("td",{parentName:"tr",align:null},"bool")))),(0,l.kt)("p",null,"Verify the CKB merkle binary tree proof."),(0,l.kt)("h4",{id:"inputs-4"},"Inputs"),(0,l.kt)("details",null,(0,l.kt)("summary",null,"Click here to view ABI"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"struct VerifyProofPayload {\n    uint8 verifyType;\n    bytes32 transactionsRoot;\n    bytes32 witnessesRoot;\n    bytes32 rawTransactionsRoot;\n    Proof proof;\n}\n\nstruct Proof {\n    uint32[] indices;\n    bytes32[] lemmas;\n    bytes32[] leaves;\n}\n")),(0,l.kt)("p",null,"If the verify_type is 0, the leaves should be in the rawTransactionsRoot, otherwise in the witnessesRoot.")),(0,l.kt)("h4",{id:"output-4"},"Output"),(0,l.kt)("details",null,(0,l.kt)("summary",null,"Click here to view ABI"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"struct Output {\n    bool ret;\n}\n"))),(0,l.kt)("h4",{id:"example-3"},"Example"),(0,l.kt)("details",null,(0,l.kt)("summary",null,"Click here to view example"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"contract VerifyCMBTRoot {\n    event VerifyCMBTRootEvent(bool);\n    event NotVerifyCMBTRootEvent();\n\n    int8 ret;\n\n    function verifyCMBTRoot(VerifyProofPayload payload) public returns (bool) {\n        address get_cell_addr = address(0x0107);\n        (bool isSuccess, bytes memory res) = get_cell_addr.staticcall(\n            abi.encode(payload)\n        );\n\n        if (isSuccess) {\n            emit VerifyCMBTRootEvent(isSuccess);\n        } else {\n            emit NotVerifyCMBTRootEvent();\n        }\n        return isSuccess;\n    }\n}\n"))))}c.isMDXComponent=!0}}]);